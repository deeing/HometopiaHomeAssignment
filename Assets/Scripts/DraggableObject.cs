using UnityEngine;public class DraggableObject : MonoBehaviour{    [SerializeField]    [Tooltip("Acceptable range within which the draggable object will snap to another object")]    private float snappingRange = 5f;    [SerializeField]    [Tooltip("Acceptable range that we can drag to relative to screen/mouse raycast")]    private float dragRange = 100f;    [SerializeField]    [Tooltip("Mask that informs what neighbor snap objects can be detected")]    private LayerMask snapMask;    [SerializeField]    [Tooltip("Mask that informs what objects we can drag along with regular mouse drag")]    private LayerMask dragMask;    // whether or not we are dragging the object    private bool isDragging = false;    // whether or not we are in snapping mode    private bool snapMode = false;    // cached transform    private Transform thisTransform;    // height of this object based on collider    private float height;    // width of this object based on collider    private float width;    private void Start()    {        thisTransform = transform;        Collider thisCollider = GetComponent<Collider>();        height = thisCollider.bounds.size.y;        width = thisCollider.bounds.size.x;    }    private void Update()    {        // reads input for if we are in snapping mode        if (Input.GetButton("SnapMode"))        {            snapMode = true;        } else        {            snapMode = false;        }    }    public void OnMouseDown()    {        // set dragging mode on        isDragging = true;    }    public void OnMouseDrag()    {        // only drag if dragging mode enabled        if (isDragging)        {            HandleDrag();        }    }    public void OnMouseUp()    {        // set dragging mode off        isDragging = false;    }    /// <summary>    /// Handles the drag for both snapping and/or regular dragging mode    /// </summary>    private void HandleDrag()    {        if (Physics.Raycast(Camera.main.ScreenPointToRay(Input.mousePosition), out RaycastHit hit, dragRange, dragMask))        {            // don't do anything if there was no hit            if (hit.collider == null)            {                return;            }            if (snapMode)            {                MoveToClosestObject(hit.point);            } else            {                MoveToMouseHit(hit.point);            }        }    }    /// <summary>    /// Moves to the closest available neighboring object within the range    /// and only works if the object is on the set layer mask    /// </summary>    /// <param name="mouseHit"></param>    private void MoveToClosestObject(Vector3 mouseHit)    {        Collider[] allNearbyObjects = Physics.OverlapSphere(mouseHit, snappingRange, snapMask);        Collider closestHit = null;        foreach (Collider currHit in allNearbyObjects)        {            if (closestHit == null)            {                closestHit = currHit;            } else            {                // split this up for readability                float currDistance = Vector3.Distance(mouseHit, currHit.ClosestPoint(mouseHit));                float closestDistance = Vector3.Distance(mouseHit, closestHit.ClosestPoint(mouseHit));                if (currDistance < closestDistance)                {                    closestHit = currHit;                }            }        }        // if no snappable neighbor found then just move to mouse        if (closestHit == null)        {            MoveToMouseHit(mouseHit);        } else        {            // move to closest neighbor            Vector3 neighborPoint = closestHit.ClosestPoint(mouseHit);            // offset by width of this object            neighborPoint += (mouseHit - neighborPoint).normalized * width / 2;            thisTransform.position = PositionOffsetByHeight(neighborPoint);        }    }    /// <summary>    /// Moves the draggable object to the given point where the mouse ray hits another objects    /// </summary>    /// <param name="mouseHit"></param>    private void MoveToMouseHit(Vector3 mouseHit)    {        thisTransform.position = PositionOffsetByHeight(mouseHit);    }    /// <summary>    /// Returns a vector to the given point/position with an increase offset with    /// the current objects height.    /// </summary>    /// <param name="point">Position that we would want to offset by the height.</param>    /// <returns></returns>    private Vector3 PositionOffsetByHeight(Vector3 point)    {        return new Vector3(point.x, point.y + height / 2, point.z);    }}